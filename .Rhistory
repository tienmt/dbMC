}
end_time <- Sys.time()
end_time - start_time
mean((true.cov.mat - sam.cov.Mat)^2)
mean((true.cov.mat - rho.fast)^2)
sum(diag(solve(true.cov.mat )%*%sam.cov.Mat - Id)/d)^2
sum(diag(solve(true.cov.mat )%*%rho.fast - Id)/d)^2
ac/(Iter+burnin)
#sum(solve(true.cov.mat )*rho.fast) -
#  determinant(solve(true.cov.mat )%*%rho.fast,logarithm = T)$modulus - d
sum(solve(true.cov.mat )*rho.fast) -n + logdet(rho.fast) -logdet(true.cov.mat)
Te.can = Te * exp( be.y * runif(d,min=-0.5,.5) )
#Te.can = Te.can/sum(Te.can)
U.can = sqrt( 1 - beta.z^2 ) * U + beta.z*rmvnorm(d,sigma= Id )
tem.can = U.can%*% ( t(U.can )* Te.can )
tem =  U%*% ( t(U )* Te )
#ss = sum(( tem.can -sam.cov.Mat)^2- (tem -sam.cov.Mat)^2)
sum( ( x%*%(solve(tem.can)%*% t(x))/n - x%*%(solve(tem)%*% t(x))/n )^2)
Te.can = Te * exp( be.y * runif(d,min=-0.5,.5) )
#Te.can = Te.can/sum(Te.can)
U.can = sqrt( 1 - beta.z^2 ) * U + beta.z*rmvnorm(d,sigma= Id )
tem.can = U.can%*% ( t(U.can )* Te.can )
tem =  U%*% ( t(U )* Te )
#ss = sum(( tem.can -sam.cov.Mat)^2- (tem -sam.cov.Mat)^2)
sum( ( x%*%(solve(tem.can)%*% t(x))/n - x%*%(solve(tem)%*% t(x))/n )^2)
Te.can = Te * exp( be.y * runif(d,min=-0.5,.5) )
#Te.can = Te.can/sum(Te.can)
U.can = sqrt( 1 - beta.z^2 ) * U + beta.z*rmvnorm(d,sigma= Id )
tem.can = U.can%*% ( t(U.can )* Te.can )
tem =  U%*% ( t(U )* Te )
#ss = sum(( tem.can -sam.cov.Mat)^2- (tem -sam.cov.Mat)^2)
sum( ( x%*%(solve(tem.can)%*% t(x))/n - x%*%(solve(tem)%*% t(x))/n )^2)
Te.can = Te * exp( be.y * runif(d,min=-0.5,.5) )
#Te.can = Te.can/sum(Te.can)
U.can = sqrt( 1 - beta.z^2 ) * U + beta.z*rmvnorm(d,sigma= Id )
tem.can = U.can%*% ( t(U.can )* Te.can )
tem =  U%*% ( t(U )* Te )
#ss = sum(( tem.can -sam.cov.Mat)^2- (tem -sam.cov.Mat)^2)
sum( ( x%*%(solve(tem.can)%*% t(x))/n - x%*%(solve(tem)%*% t(x))/n )^2)
Te.can = Te * exp( be.y * runif(d,min=-0.5,.5) )
#Te.can = Te.can/sum(Te.can)
U.can = sqrt( 1 - beta.z^2 ) * U + beta.z*rmvnorm(d,sigma= Id )
tem.can = U.can%*% ( t(U.can )* Te.can )
tem =  U%*% ( t(U )* Te )
#ss = sum(( tem.can -sam.cov.Mat)^2- (tem -sam.cov.Mat)^2)
sum( ( x%*%(solve(tem.can)%*% t(x))/n - x%*%(solve(tem)%*% t(x))/n )^2)
Te.can = Te * exp( be.y * runif(d,min=-0.5,.5) )
#Te.can = Te.can/sum(Te.can)
U.can = sqrt( 1 - beta.z^2 ) * U + beta.z*rmvnorm(d,sigma= Id )
tem.can = U.can%*% ( t(U.can )* Te.can )
tem =  U%*% ( t(U )* Te )
#ss = sum(( tem.can -sam.cov.Mat)^2- (tem -sam.cov.Mat)^2)
sum( ( x%*%(solve(tem.can)%*% t(x))/n - x%*%(solve(tem)%*% t(x))/n )^2)
Te.can = Te * exp( be.y * runif(d,min=-0.5,.5) )
#Te.can = Te.can/sum(Te.can)
U.can = sqrt( 1 - beta.z^2 ) * U + beta.z*rmvnorm(d,sigma= Id )
tem.can = U.can%*% ( t(U.can )* Te.can )
tem =  U%*% ( t(U )* Te )
#ss = sum(( tem.can -sam.cov.Mat)^2- (tem -sam.cov.Mat)^2)
sum( ( x%*%(solve(tem.can)%*% t(x))/n - x%*%(solve(tem)%*% t(x))/n )^2)
sum(  x%*%(solve(tem.can)%*% t(x))/n - x%*%(solve(tem)%*% t(x))/n )
Te.can = Te * exp( be.y * runif(d,min=-0.5,.5) )
#Te.can = Te.can/sum(Te.can)
U.can = sqrt( 1 - beta.z^2 ) * U + beta.z*rmvnorm(d,sigma= Id )
tem.can = U.can%*% ( t(U.can )* Te.can )
tem =  U%*% ( t(U )* Te )
#ss = sum(( tem.can -sam.cov.Mat)^2- (tem -sam.cov.Mat)^2)
sum(  x%*%(solve(tem.can)%*% t(x))/n - x%*%(solve(tem)%*% t(x))/n )
Te.can = Te * exp( be.y * runif(d,min=-0.5,.5) )
#Te.can = Te.can/sum(Te.can)
U.can = sqrt( 1 - beta.z^2 ) * U + beta.z*rmvnorm(d,sigma= Id )
tem.can = U.can%*% ( t(U.can )* Te.can )
tem =  U%*% ( t(U )* Te )
#ss = sum(( tem.can -sam.cov.Mat)^2- (tem -sam.cov.Mat)^2)
sum(  x%*%(solve(tem.can)%*% t(x))/n - x%*%(solve(tem)%*% t(x))/n )
Te.can = Te * exp( be.y * runif(d,min=-0.5,.5) )
#Te.can = Te.can/sum(Te.can)
U.can = sqrt( 1 - beta.z^2 ) * U + beta.z*rmvnorm(d,sigma= Id )
tem.can = U.can%*% ( t(U.can )* Te.can )
tem =  U%*% ( t(U )* Te )
#ss = sum(( tem.can -sam.cov.Mat)^2- (tem -sam.cov.Mat)^2)
sum(  x%*%(solve(tem.can)%*% t(x))/n - x%*%(solve(tem)%*% t(x))/n )
Te.can = Te * exp( be.y * runif(d,min=-0.5,.5) )
#Te.can = Te.can/sum(Te.can)
U.can = sqrt( 1 - beta.z^2 ) * U + beta.z*rmvnorm(d,sigma= Id )
tem.can = U.can%*% ( t(U.can )* Te.can )
tem =  U%*% ( t(U )* Te )
#ss = sum(( tem.can -sam.cov.Mat)^2- (tem -sam.cov.Mat)^2)
sum(  x%*%(solve(tem.can)%*% t(x))/n - x%*%(solve(tem)%*% t(x))/n )
Te.can = Te * exp( be.y * runif(d,min=-0.5,.5) )
#Te.can = Te.can/sum(Te.can)
U.can = sqrt( 1 - beta.z^2 ) * U + beta.z*rmvnorm(d,sigma= Id )
tem.can = U.can%*% ( t(U.can )* Te.can )
tem =  U%*% ( t(U )* Te )
#ss = sum(( tem.can -sam.cov.Mat)^2- (tem -sam.cov.Mat)^2)
sum(  x%*%(solve(tem.can)%*% t(x))/n - x%*%(solve(tem)%*% t(x))/n )
################################################
####### MAIN CODES: ############################
rho.fast = matrix(0,nr=d,nc=d)
Te = rexp(d)
U <-  rmvnorm(d, sigma = Id )
Lamb = Te/sum(Te)
gamm = n/2
#MCMC loop
Iter = 300
burnin = 10
be.y = 0.05
beta.z = .0005
ro = 1
ac = 0
U.can = U
Te.can = Te
start_time <- Sys.time()
for(t in 1:(Iter+burnin)){
Te.can = Te * exp( be.y * runif(d,min=-0.5,.5) )
#Te.can = Te.can/sum(Te.can)
U.can = sqrt( 1 - beta.z^2 ) * U + beta.z*rmvnorm(d,sigma= Id )
tem.can = U.can%*% ( t(U.can )* Te.can )
tem =  U%*% ( t(U )* Te )
#ss = sum(( tem.can -sam.cov.Mat)^2- (tem -sam.cov.Mat)^2)
sum(  x%*%(solve(tem.can)%*% t(x))/n - x%*%(solve(tem)%*% t(x))/n )
r.prior = sum( (ro)*log(Te.can/Te) -Te.can +Te,na.rm = T )
if(log(runif(1)) <= -gamm*ss + r.prior){
Te<- Te.can
U = U.can
ac = ac +1
print(t)
}
#approx rho
if(t>burnin){
rho.fast = U %*% ( t(U) *Te ) /(t-burnin) + rho.fast*(1-1/(t-burnin))
}
}
end_time <- Sys.time()
end_time - start_time
mean((true.cov.mat - sam.cov.Mat)^2)
mean((true.cov.mat - rho.fast)^2)
sum(diag(solve(true.cov.mat )%*%sam.cov.Mat - Id)/d)^2
sum(diag(solve(true.cov.mat )%*%rho.fast - Id)/d)^2
ac/(Iter+burnin)
#sum(solve(true.cov.mat )*rho.fast) -
#  determinant(solve(true.cov.mat )%*%rho.fast,logarithm = T)$modulus - d
sum(solve(true.cov.mat )*rho.fast) -n + logdet(rho.fast) -logdet(true.cov.mat)
sum(( tem.can -sam.cov.Mat)^2- (tem -sam.cov.Mat)^2)
sum(( tem.can -sam.cov.Mat)^2- (tem -sam.cov.Mat)^2)
sum(( tem.can -sam.cov.Mat)^2- (tem -sam.cov.Mat)^2)
sum(( tem.can -sam.cov.Mat)^2- (tem -sam.cov.Mat)^2)
sum(  x%*%(solve(tem.can)%*% t(x)) - x%*%(solve(tem)%*% t(x)) )
sum(  x%*%(solve(tem.can)%*% t(x)) - x%*%(solve(tem)%*% t(x)) )
sum(  x%*%(solve(tem.can)%*% t(x)) - x%*%(solve(tem)%*% t(x)) )
#MCMC loop
Iter = 300
burnin = 10
be.y = 0.05
beta.z = .0005
ro = 1
ac = 0
U.can = U
Te.can = Te
start_time <- Sys.time()
for(t in 1:(Iter+burnin)){
Te.can = Te * exp( be.y * runif(d,min=-0.5,.5) )
#Te.can = Te.can/sum(Te.can)
U.can = sqrt( 1 - beta.z^2 ) * U + beta.z*rmvnorm(d,sigma= Id )
tem.can = U.can%*% ( t(U.can )* Te.can )
tem =  U%*% ( t(U )* Te )
#ss = sum(( tem.can -sam.cov.Mat)^2- (tem -sam.cov.Mat)^2)
sum(  x%*%(solve(tem.can)%*% t(x)) - x%*%(solve(tem)%*% t(x)) )
r.prior = sum( (ro)*log(Te.can/Te) -Te.can +Te,na.rm = T )
if(log(runif(1)) <= -gamm*ss + r.prior){
Te<- Te.can
U = U.can
ac = ac +1
print(t)
}
#approx rho
if(t>burnin){
rho.fast = U %*% ( t(U) *Te ) /(t-burnin) + rho.fast*(1-1/(t-burnin))
}
}
end_time <- Sys.time()
end_time - start_time
mean((true.cov.mat - sam.cov.Mat)^2)
mean((true.cov.mat - rho.fast)^2)
sum(diag(solve(true.cov.mat )%*%sam.cov.Mat - Id)/d)^2
sum(diag(solve(true.cov.mat )%*%rho.fast - Id)/d)^2
ac/(Iter+burnin)
#sum(solve(true.cov.mat )*rho.fast) -
#  determinant(solve(true.cov.mat )%*%rho.fast,logarithm = T)$modulus - d
sum(solve(true.cov.mat )*rho.fast) -n + logdet(rho.fast) -logdet(true.cov.mat)
mahalanobis(x, cov = tem.can)
mahalanobis(x, center = 0, cov = tem.can)
str(x)
x%*%(solve(tem.can)%*% t(x))
################################################
####### MAIN CODES: ############################
rho.fast = matrix(0,nr=d,nc=d)
Te = rexp(d)
U <-  rmvnorm(d, sigma = Id )
Lamb = Te/sum(Te)
gamm = n/2
#MCMC loop
Iter = 300
burnin = 10
be.y = 0.05
beta.z = .0005
ro = 1
ac = 0
U.can = U
Te.can = Te
start_time <- Sys.time()
for(t in 1:(Iter+burnin)){
Te.can = Te * exp( be.y * runif(d,min=-0.5,.5) )
#Te.can = Te.can/sum(Te.can)
U.can = sqrt( 1 - beta.z^2 ) * U + beta.z*rmvnorm(d,sigma= Id )
tem.can = U.can%*% ( t(U.can )* Te.can )
tem =  U%*% ( t(U )* Te )
#ss = sum(( tem.can -sam.cov.Mat)^2- (tem -sam.cov.Mat)^2)
ss = sum ( mahalanobis(x, center = 0, cov = tem.can) -mahalanobis(x, center = 0, cov = tem) )
r.prior = sum( (ro)*log(Te.can/Te) -Te.can +Te,na.rm = T )
if(log(runif(1)) <= -gamm*ss + r.prior){
Te<- Te.can
U = U.can
ac = ac +1
print(t)
}
#approx rho
if(t>burnin){
rho.fast = U %*% ( t(U) *Te ) /(t-burnin) + rho.fast*(1-1/(t-burnin))
}
}
end_time <- Sys.time()
end_time - start_time
mean((true.cov.mat - sam.cov.Mat)^2)
mean((true.cov.mat - rho.fast)^2)
sum(diag(solve(true.cov.mat )%*%sam.cov.Mat - Id)/d)^2
sum(diag(solve(true.cov.mat )%*%rho.fast - Id)/d)^2
ac/(Iter+burnin)
#sum(solve(true.cov.mat )*rho.fast) -
#  determinant(solve(true.cov.mat )%*%rho.fast,logarithm = T)$modulus - d
sum(solve(true.cov.mat )*rho.fast) -n + logdet(rho.fast) -logdet(true.cov.mat)
##########################
# model-free Bayesian covariance estimation
##########################
logdet = function(x) return(determinant(x,logarithm = T)[[1]][1])
library(mvtnorm)
# dimension of covariates
d = 100
Id = diag(d)
# number of samples
n = 10
### simulate The "true" covariance matrix  ###
u = rmvnorm(d,sigma=diag(d))
true.cov.mat = t(u)%*%u
### calculate the frequency matrix after simulating sample
x = rmvnorm(n, sigma = true.cov.mat)
sam.cov.Mat = t(x)%*%x/n
mean((true.cov.mat - sam.cov.Mat)^2)
sum(diag(solve(true.cov.mat,sam.cov.Mat) - Id)^2)
##########################
# model-free Bayesian covariance estimation
##########################
logdet = function(x) return(determinant(x,logarithm = T)[[1]][1])
library(mvtnorm)
# dimension of covariates
d = 100
Id = diag(d)
# number of samples
n = 1000
### simulate The "true" covariance matrix  ###
u = rmvnorm(d,sigma=diag(d))
true.cov.mat = t(u)%*%u
### calculate the frequency matrix after simulating sample
x = rmvnorm(n, sigma = true.cov.mat)
sam.cov.Mat = t(x)%*%x/n
mean((true.cov.mat - sam.cov.Mat)^2)
sum(diag(solve(true.cov.mat,sam.cov.Mat) - Id)^2)
################################################
####### MAIN CODES: ############################
rho.fast = matrix(0,nr=d,nc=d)
Te = rexp(d)
U <-  rmvnorm(d, sigma = Id )
Lamb = Te/sum(Te)
gamm = n/2
#MCMC loop
Iter = 300
burnin = 10
be.y = 0.05
beta.z = .0005
ro = 1
ac = 0
U.can = U
Te.can = Te
start_time <- Sys.time()
for(t in 1:(Iter+burnin)){
Te.can = Te * exp( be.y * runif(d,min=-0.5,.5) )
#Te.can = Te.can/sum(Te.can)
U.can = sqrt( 1 - beta.z^2 ) * U + beta.z*rmvnorm(d,sigma= Id )
tem.can = U.can%*% ( t(U.can )* Te.can )
tem =  U%*% ( t(U )* Te )
#ss = sum(( tem.can -sam.cov.Mat)^2- (tem -sam.cov.Mat)^2)
ss = sum ( mahalanobis(x, center = 0, cov = tem.can) -mahalanobis(x, center = 0, cov = tem) )
r.prior = sum( (ro)*log(Te.can/Te) -Te.can +Te,na.rm = T )
if(log(runif(1)) <= -gamm*ss + r.prior){
Te<- Te.can
U = U.can
ac = ac +1
print(t)
}
#approx rho
if(t>burnin){
rho.fast = U %*% ( t(U) *Te ) /(t-burnin) + rho.fast*(1-1/(t-burnin))
}
}
end_time <- Sys.time()
end_time - start_time
mean((true.cov.mat - sam.cov.Mat)^2)
mean((true.cov.mat - rho.fast)^2)
sum(diag(solve(true.cov.mat )%*%sam.cov.Mat - Id)/d)^2
sum(diag(solve(true.cov.mat )%*%rho.fast - Id)/d)^2
ac/(Iter+burnin)
#sum(solve(true.cov.mat )*rho.fast) -
#  determinant(solve(true.cov.mat )%*%rho.fast,logarithm = T)$modulus - d
sum(solve(true.cov.mat )*rho.fast) -n + logdet(rho.fast) -logdet(true.cov.mat)
eigen(true.cov.mat)$values
Te.can
rexp(d)
svd(true.cov.mat)$d
exp( be.y * runif(d,min=-0.5,.5) )
rnorm(d)
rgamma(10)
rgamma(10,1)
rgamma(10,10)
rgamma(d,10)
################################################
####### MAIN CODES: ############################
rho.fast = matrix(0,nr=d,nc=d)
Te = rgamma(d,10)
U <-  rmvnorm(d, sigma = Id )
gamm = n/2
#MCMC loop
Iter = 300
burnin = 10
be.y = 0.05
beta.z = .0005
ro = 1
ac = 0
U.can = U
Te.can = Te
start_time <- Sys.time()
for(t in 1:(Iter+burnin)){
Te.can = Te * sqrt( 1 - be.y^2 ) + be.y*rgamma(d,10)
#Te.can = Te.can/sum(Te.can)
U.can = sqrt( 1 - beta.z^2 ) * U + beta.z*rmvnorm(d,sigma= Id )
tem.can = U.can%*% ( t(U.can )* Te.can )
tem =  U%*% ( t(U )* Te )
#ss = sum(( tem.can -sam.cov.Mat)^2- (tem -sam.cov.Mat)^2)
ss = sum ( mahalanobis(x, center = 0, cov = tem.can) -mahalanobis(x, center = 0, cov = tem) )
r.prior = sum( (ro)*log(Te.can/Te) -Te.can +Te,na.rm = T )
if(log(runif(1)) <= -gamm*ss + r.prior){
Te<- Te.can
U = U.can
ac = ac +1
print(t)
}
#approx rho
if(t>burnin){
rho.fast = U %*% ( t(U) *Te ) /(t-burnin) + rho.fast*(1-1/(t-burnin))
}
}
end_time <- Sys.time()
end_time - start_time
mean((true.cov.mat - sam.cov.Mat)^2)
mean((true.cov.mat - rho.fast)^2)
sum(diag(solve(true.cov.mat )%*%sam.cov.Mat - Id)/d)^2
sum(diag(solve(true.cov.mat )%*%rho.fast - Id)/d)^2
ac/(Iter+burnin)
#sum(solve(true.cov.mat )*rho.fast) -
#  determinant(solve(true.cov.mat )%*%rho.fast,logarithm = T)$modulus - d
sum(solve(true.cov.mat )*rho.fast) -n + logdet(rho.fast) -logdet(true.cov.mat)
50-21
library("glmnet", lib.loc="~/Library/R/4.0/library")
setwd("~/Dropbox/ongoing_works/matrix Completion")
install.packages("~/Dropbox/ongoing_works/matrix Completion/dbMC_1.0.0.tar.gz", repos = NULL, type = "source", lib="/Library/Frameworks/R.framework/Versions/4.0/Resources/library")
library("dbMC", lib.loc="~/Library/R/4.0/library")
browseVignettes(package = 'dbMC')
library(devtools)
build(vignettes = T)
setwd("~/Dropbox/ongoing_works/matrix Completion")
document()
document()
setwd("~/Dropbox/ongoing_works/matrix Completion/dbMC")
document()
build_vignettes()
tools::buildVignettes(dir = ".", tangle=TRUE)
dir.create("inst/doc")
dir.create("./inst/doc")
dir.create("./inst")
dir.create("inst/doc")
file.copy(dir("vignettes", full.names=TRUE), "inst/doc", overwrite=TRUE)
install.packages("~/Dropbox/ongoing_works/matrix Completion/dbMC_1.0.0.tar.gz", repos = NULL, type = "source", lib="/Library/Frameworks/R.framework/Versions/4.0/Resources/library")
library(dbMC)
browseVignettes(package = 'dbMC')
n = 100
p = 100
J = 2  # the true low-rank
np = n*p
sig2 = 1
missfrac = 0.5
# xtrue is the underlying matrix that we do not know and want to recover it
xtrue = matrix(rnorm(n*J),n,J)%*%matrix(rnorm(J*p),J,p)
# generating missing entries locations
imiss = sample(np,np*missfrac,replace=FALSE)
# xna is the observed matrix with missing entries
xna = xtrue + matrix(rnorm(np, sd = sig2),nr = n,nc = p)
xna[imiss] = NA
lamda = 2.5*sig2*sqrt(n*p)
# note that we only have xna as our initial data
# first, fit a softImpute method
fit1 = softImpute(xna, type = 'als')
# complete the matrix by a softImpute method
ximp = complete(xna,fit1)
mean((ximp - xtrue)^2);rankMatrix(ximp,.1)[1]
#> [1] 0.5555512
#> [1] 11
# now, de-biased the softImpute method
x.db = dbmc(x = xna,
ximp = ximp,
entries_miss = imiss,
est_rank = 2)
# smaller mse with de-biased estimator
mean((x.db - xtrue)^2);rankMatrix(x.db,.1)[1]
#> [1] 0.08138654
#> [1] 2
# confidence intervals
CI_mc(i=1,j=2,alpha = 0.05,X.db = x.db,missfrac = 0.5,est_rank = 2,sigma2 = 1)
#> $CI
#> [1] -0.5028102  0.4424451
#>
#> $`(i,j)`
#> [1] 1 2
#>
#> $v.ij
#>            [,1]
#> [1,] 0.05814898
# true value
xtrue[1,2]
CI_mc(i=1,j=1,alpha = 0.05,X.db = x.db,missfrac = 0.5,est_rank = 2,sigma2 = 1)
xtrue[1,1]
require(softImpute)
n = 100
p = 100
J = 2  # the true low-rank
np = n*p
sig2 = 1
missfrac = 0.5
xtrue = matrix(rnorm(n*J),n,J)%*%matrix(rnorm(J*p),J,p)
imiss = sample(np,np*missfrac,replace=FALSE)
xna = xtrue + matrix(rnorm(np, sd = sig2),nr = n,nc = p)
xna[imiss] = NA
lamda = 2.5*sig2*sqrt(n*p)
fit1 = softImpute(xna, type = 'als')
ximp = complete(xna,fit1)
mean((ximp - xtrue)^2);rankMatrix(ximp,.1)[1]
x.db = dbmc(x = xna,
ximp = ximp,
entries_miss = imiss,
est_rank = 2)
mean((x.db - xtrue)^2);rankMatrix(x.db,.1)[1]
xtrue[1,1]
x.db[1,1]
CI_mc(i=1,j=1,alpha = 0.05,X.db = x.db,missfrac = 0.5,est_rank = 2,sigma2 = 1)
x.db[i,j]
i =1
j =1
x.db[i,j] + c(-1,1)* stats::qnorm(1-alpha/2)
alpha = 0.005
x.db[i,j] + c(-1,1)* stats::qnorm(1-alpha/2)
alpha = 0.05
x.db[i,j] + c(-1,1)* stats::qnorm(1-alpha/2)
xtrue[1,1]
x.db[i,j] + c(-1,1)* stats::qnorm(1-alpha/2)*sqrt(c(v.ij) )
v.ij = 0.03507048
x.db[i,j] + c(-1,1)* stats::qnorm(1-alpha/2)*sqrt(c(v.ij) )
CI_mc(i=1,j=2,alpha = 0.05,X.db = x.db,missfrac = 0.5,est_rank = 2,sigma2 = 1)
xtrue[1,2]
CI_mc(i=1,j=1,alpha = 0.05,X.db = x.db,missfrac = 0.5,est_rank = 2,sigma2 = 1)
xtrue[1,1]
x.db[i,j] + c(-1,1)* stats::qnorm(1-alpha/2)*sqrt(c(v.ij))
CI_mc = function(i,j,
alpha = 0.05,
missfrac,
X.db,
est_rank,
sigma2 = 1){
tam = svd(X.db,nu =est_rank,nv = est_rank)
n = nrow(X.db)
p = ncol(X.db)
lamda = 2.5*sigma2*sqrt(n*p)
Xd = tam$u[,1:est_rank] %*% diag( sqrt(tam$d[1:est_rank] + lamda) )
Yd = tam$v[,1:est_rank]%*% diag( sqrt(tam$d[1:est_rank] + lamda) )
v.ij = sigma2*( Xd[i,] %*%solve(crossprod(Xd))%*% Xd[i,] + Yd[j,] %*%solve(crossprod(Yd))%*% Yd[j,])/(1-missfrac)
ci = x.db[i,j] + c(-1,1)* stats::qnorm(1-alpha/2)*sqrt(c(v.ij))
return(list('CI' = ci,'(i,j)' = c(i,j),v.ij = c(v.ij) ))
}
CI_mc(i=1,j=1,alpha = 0.05,X.db = x.db,missfrac = 0.5,est_rank = 2,sigma2 = 1)
xtrue[1,1]
document()
rm(list = c("CI_mc"))
document()
build_vignettes()
build_vignettes()
